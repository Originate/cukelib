<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"request_support.js.html":{"id":"request_support.js.html","title":"Source: request_support.js","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Source: request_support.js /** * requestSupport * @module requestSupport */ // @flow const _ = require('lodash'); const yaml = require('js-yaml'); const handlebars = require('handlebars'); const requestPromise = require('request-promise'); const { parseStepArg } = require('./utilities'); const { get, set, unset, log, log3, initializeWith } = require('./universe').namespaceFactory('_cukelib'); const requestCommon = (routeStr, options) =&gt; { const combinedOptions = _.defaults(options, get('_request.defaultOptions')); const url = handlebars.compile(`${combinedOptions.host}/${routeStr.replace(/^\\//, '')}`)(get()); const requestOptions = _.defaults({ url }, _.omit(combinedOptions, 'host')); set('_request.requestOptions', requestOptions); log3('log3', 'requestOptions', requestOptions); const responsePromise = requestPromise(requestOptions); set('_request.responsePromise', responsePromise); return responsePromise.then((result) =&gt; { log('response headers', result.headers); log('response body', result.body); unset('_request.responsePromise'); set('_request.response', result); return responsePromise; }) .catch((err) =&gt; { log('err', err); return responsePromise; }); }; const parseYamlBody = (bodyStr) =&gt; { if (_.isPlainObject(bodyStr)) return bodyStr; if (!_.isString(bodyStr)) { throw new Error(`expected a string, but got ${bodyStr}`); } try { return yaml.safeLoad(bodyStr); } catch (err) { err.message += ' Error parsing:\\n' + bodyStr; // eslint-disable-line prefer-template throw err; } }; module.exports = { /** * Initializes the &quot;request&quot; defaults. Should be called in a context which * contains the CucumberJS methods (`Given`, `Then`, `Before`, etc.) * * @example * requestSupport.initialize.call(this, options); * * @param {object} [options={}] merged with * Merged with [standard defaults](request_support.js.html#sunlight-1-line-67) * to set request defaultOptions * * @returns undefined */ initialize(options: Object = {}) { initializeWith.call(this, { _request: { defaultOptions: _.defaults({}, options, { host: 'http://localhost:3000', method: 'GET', simple: false, body: {}, resolveWithFullResponse: true, json: true, jar: true, }), }, }); }, /** * requestGET - Description * * @param {string} routeStr Description * @param {object} [options={}] Description * * @returns {type} Description */ requestGET(routeStr: string, options: Object = {}) { return requestCommon( routeStr, _.assign({ method: 'GET' }, options) ); }, requestPUT(routeStr: string, bodyStr: string|Object, options: Object = {}) { const done = (typeof bodyStr === 'function') ? bodyStr : null; const responsePromise = requestCommon( routeStr, _.assign({ method: 'PUT', body: done ? {} : parseYamlBody(parseStepArg(bodyStr)) }, options) ); if (done) { responsePromise.asCallback(done); return null; } return responsePromise; }, requestDELETE(routeStr: string, options: Object = {}) { return requestCommon( routeStr, _.assign({ method: 'DELETE' }, options) ); }, /** * Executes POST request to given `routeStr` * * `bodyStr` * - as a string will be interpreted as JSON and passed to the request. * - as an object with a `raw` property it is interpreted as a single tow cucumber table. * The table contents are merged, interpreted as JSON and passed to the request. * - as a plainObject it is passsed directly to the request. * - as a function it is assumed to be a `done` callback and an empty body is sent to the request * * @param {string} routeStr * @param {string|object|function} bodyStr * @param {object} [options={}] Overides to the request defaults. * * @returns {Promise|null} Response promise from `request` or `null` for callback style calls. */ requestPOST(routeStr: string, bodyStr: string|Object, options: Object = {}) { const done = (typeof bodyStr === 'function') ? bodyStr : null; const responsePromise = requestCommon( routeStr, _.assign({ method: 'POST', body: done ? {} : parseYamlBody(parseStepArg(bodyStr)) }, options) ); if (done) { responsePromise.asCallback(done); return null; } return responsePromise; }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"service_control_index.js.html":{"id":"service_control_index.js.html","title":"Source: service_control/index.js","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Source: service_control/index.js /** * @module serviceControl */ // @flow const _ = require('lodash'); const Promise = require('bluebird'); const universe = require('../universe'); const serviceControlNS = universe.namespaceFactory('_cukelib'); const { get, set, log3, unset, hasKey, getCukeContext, initializeWith } = serviceControlNS; const listServices = (serviceRoot: string, depth: number) =&gt; { let serviceList = []; _.forIn(get(serviceRoot ? `_services.${serviceRoot}` : '_services'), (candidate, name) =&gt; { const namePath = serviceRoot ? `${serviceRoot}.${name}` : name; if (candidate.cukeContext) { serviceList.push(namePath); } else if (depth &lt; 10) { const deepServiceList = listServices(namePath, depth + 1); serviceList = serviceList.concat(deepServiceList); } }); return serviceList; }; const serviceControl = module.exports = { serviceControlNS, addBoilerPlate(prefix: string, serviceObject: Object) { return _.defaults(serviceObject, { initialize() { return serviceControl.initialize.call(this); }, getService(name) { return serviceControl.getService(`${prefix}.${name}`); }, }); }, initialize() { if (hasKey('_services')) return; initializeWith.call(this, { _services: {} }); const cukeContextKiller = (cukeContext) =&gt; { const killTheseServices = listServices('', 0) .filter((namePath) =&gt; get(`_services.${namePath}`).cukeContext === cukeContext); log3('log3', 'killTheseServices', killTheseServices); return Promise.map(killTheseServices, (name) =&gt; serviceControl.stopService(name)); }; this.After(cukeContextKiller.bind(null, 'scenario')); this.registerHandler('AfterFeature', cukeContextKiller.bind(null, 'feature')); this.registerHandler('AfterFeatures', cukeContextKiller.bind(null, 'universe')); }, stopService(name: string) { log3('log3', 'serviceControl/stopService', name); const service = get(`_services.${name}`); if (!service) return Promise.resolve(`no service for ${name}`); unset(`_services.${name}`); if (service.stop) { return service.stop(); } else if ((service.proc || {}).kill) { service.removeListeners(); service.proc.kill('SIGTERM'); return service.exitPromise; } throw new Error(`Don't know how to stop service &quot;${name}&quot;`); }, /** * @param {string} name service name * * @returns {Object} universe service object root */ getService(name: string) { return get(`_services.${name}`); }, launchService(name: string, start: () =&gt; Object) { log3('log3', 'serviceControl/launchService', name); if (!get('_services')) { throw new Error('tried to launchService before service_control was initialized'); } return serviceControl.stopService(name) .then(start) .then((service) =&gt; { if (!service.stop || !_.isFunction(service.stop)) { throw new Error(`service '${name}' is missing a stop function`); } set(`_services.${name}`, service); service.name = name; // eslint-disable-line no-param-reassign service.cukeContext = getCukeContext(); // eslint-disable-line no-param-reassign return service; }); }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"shell_support.js.html":{"id":"shell_support.js.html","title":"Source: shell_support.js","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Source: shell_support.js /** * @module shellSupport */ // @flow const _ = require('lodash'); const expect = require('chai').expect; const childProcess = require('child_process'); const { parseStepArg } = require('./utilities'); const { get, set, initializeWith } = require('./universe').namespaceFactory('_cukelib'); type Stream = 'STDOUT' | 'STDERR'; const shellSupport = module.exports = { initialize() { return initializeWith.call(this); }, /** * Runs `scriptStr` lines in a childProcess * * Results of the run are stored in the universe at * `_shell.STDOUT`, `_shell.STDERR`, and `_shell.error`. * In particular the status code of execution is in `_shell.error.code` * * Note that the `STDOUT` ans `STDERR` result accumulate over multiple steps. * Use {@link module:shell_support.resetShell|resetShell} to clear the previous results. * * @param {string} scriptStr shell script * @param {function} done childProcess completed callback * * @returns undefined */ runShell(scriptStr: string|Object, done: Function) { const script = parseStepArg(scriptStr); childProcess.exec(script, (error, stdout, stderr) =&gt; { set('_shell.STDOUT', (get('_shell.STDOUT') || '') + stdout); set('_shell.STDERR', (get('_shell.STDERR') || '') + stderr); set('_shell.error', error); done(error); }); }, /** * Same as {@link module:shell_support.runShell|runShell}, * but doesn't fail when the execution errors. */ runSkipError(scriptStr: string|Object, done: Function) { shellSupport.runShell.call(this, scriptStr, () =&gt; done()); }, /** resets (clears) the shell STDERR and STDOUT universe variable. * (Shell output is cumulative over multiple steps.) */ resetShell() { set('_shell.STDOUT', ''); set('_shell.STDERR', ''); set('_shell.error', null); }, inspectShellOutput() { /* eslint-disable no-console */ console.log('STDOUT:'); console.log(get('_shell.STDOUT')); console.log('STDERR:'); console.log(get('_shell.STDERR')); const shellErr = get('_shell.error'); if (shellErr) { console.log('Shell Error:'); console.log(shellErr); } /* eslint-enable no-console */ }, resultEqual(stream: Stream, data: string|Object) { expect(get(`_shell.${stream}`).trim()).to.equal(parseStepArg(data)); }, resultErrorCode(targetCode: string) { expect(get('_shell.error.code')).to.equal(_.toNumber(targetCode)); }, resultRegexMatch(stream: Stream, data: string|Object) { const re = new RegExp(data); expect(get(`_shell.${stream}`).trim()).to.match(re); }, resultTemplateMatch(stream: Stream, targetTemplate: string|Object) { const target = parseStepArg(targetTemplate); expect(get(`_shell.${stream}`).trim()).to.equal(target); }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"utilities_index.js.html":{"id":"utilities_index.js.html","title":"Source: utilities/index.js","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Source: utilities/index.js /** * @module utilities */ const _ = require('lodash'); const handlebars = require('handlebars'); const { get } = require('../universe').namespaceFactory('_cukelib'); module.exports = { /** * Parses a step argument so that it treats a single cell cucumber table as plain text, * and then evaluates it as a handlebars template using the cucumber _cukelib namespace object. * * @param {string|Object} stepArg * * @returns {string} */ parseStepArg(stepArg) { let toCompile = stepArg; if (stepArg.raw) { const dataTable = stepArg.raw(); if (dataTable.length === 1) { toCompile = dataTable[0].join('|'); } else { throw new Error(&quot;This doesn't look like a single cell table.&quot;); } } return _.isString(toCompile) ? handlebars.compile(toCompile.trim())(get()) : stepArg; }, }; × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Modules × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" cukelib Modules requestSupportserviceControlshellSupportutilities cukelib module documentationback to github × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"module-requestSupport.html":{"id":"module-requestSupport.html","title":"Module: requestSupport","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Module: requestSupport requestSupport Source: request_support.js, line 1 Methods &lt;static&gt; initialize( [options]) Initializes the &quot;request&quot; defaults. Should be called in a context whichcontains the CucumberJS methods (Given, Then, Before, etc.) Parameters: Name Type Argument Default Description options object &lt;optional&gt; {} merged with Merged with standard defaults to set request defaultOptions Source: request_support.js, line 61 Returns: undefined Example requestSupport.initialize.call(this, options); &lt;static&gt; requestGET(routeStr [, options]) requestGET - Description Parameters: Name Type Argument Default Description routeStr string Description options object &lt;optional&gt; {} Description Source: request_support.js, line 85 Returns: Description Type type &lt;static&gt; requestPOST(routeStr, bodyStr [, options]) Executes POST request to given routeStr bodyStr as a string will be interpreted as JSON and passed to the request. as an object with a raw property it is interpreted as a single tow cucumber table.The table contents are merged, interpreted as JSON and passed to the request. as a plainObject it is passsed directly to the request. as a function it is assumed to be a done callback and an empty body is sent to the request Parameters: Name Type Argument Default Description routeStr string bodyStr string | object | function options object &lt;optional&gt; {} Overides to the request defaults. Source: request_support.js, line 119 Returns: Response promise from request or null for callback style calls. Type Promise | null × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"module-serviceControl.html":{"id":"module-serviceControl.html","title":"Module: serviceControl","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Module: serviceControl Source: service_control/index.js, line 1 Methods &lt;static&gt; getService(name) Parameters: Name Type Description name string service name Source: service_control/index.js, line 74 Returns: universe service object root Type Object × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"module-shellSupport.html":{"id":"module-shellSupport.html","title":"Module: shellSupport","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Module: shellSupport Source: shell_support.js, line 1 Methods &lt;static&gt; resetShell() resets (clears) the shell STDERR and STDOUT universe variable.(Shell output is cumulative over multiple steps.) Source: shell_support.js, line 52 &lt;static&gt; runShell(scriptStr, done) Runs scriptStr lines in a childProcess Results of the run are stored in the universe at_shell.STDOUT, _shell.STDERR, and _shell.error.In particular the status code of execution is in _shell.error.code Note that the STDOUT ans STDERR result accumulate over multiple steps.Use resetShell to clear the previous results. Parameters: Name Type Description scriptStr string shell script done function childProcess completed callback Source: shell_support.js, line 31 Returns: undefined &lt;static&gt; runSkipError() Same as runShell,but doesn't fail when the execution errors. Source: shell_support.js, line 45 × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "},"module-utilities.html":{"id":"module-utilities.html","title":"Module: utilities","body":" cukelib Modules requestSupportserviceControlshellSupportutilities Module: utilities Source: utilities/index.js, line 1 Methods &lt;static&gt; parseStepArg(stepArg) Parses a step argument so that it treats a single cell cucumber table as plain text,and then evaluates it as a handlebars template using the cucumber _cukelib namespace object. Parameters: Name Type Description stepArg string | Object Source: utilities/index.js, line 17 Returns: Type string × Search results Close Documentation generated by JSDoc 3.4.3 on Thu Feb 2nd 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
